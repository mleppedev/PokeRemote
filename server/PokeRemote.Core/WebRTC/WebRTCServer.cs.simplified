using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Threading;
using System.IO;
using Newtonsoft.Json;

using SIPSorcery.Net;
using SIPSorcery.Media;
using PokeRemote.Core.Capture;
using PokeRemote.Core.Input;

namespace PokeRemote.Core.WebRTC
{
    /// <summary>
    /// Clase que maneja la comunicación WebRTC entre el cliente y el servidor.
    /// </summary>
    public class WebRTCServer : IDisposable
    {
        private RTCPeerConnection? _pc;
        private RTCDataChannel? _dataChannel;
        
        // Captura de pantalla
        private ScreenCapture _screenCapture;
        
        // Gestor de teclado para controlar los juegos
        private KeyboardInput _keyboardInput;
        
        // Estado
        private bool _isConnected = false;
        private bool _isDisposed = false;
        private bool _isStreamingVideo = false;
        
        // Video source
        private WindowsScreenSource? _screenSource;
        private VideoFramePump? _frameSource;
        
        // Eventos
        public event EventHandler<string>? LogMessage;
        public event EventHandler<RTCPeerConnectionState>? ConnectionStateChanged;
        
        public bool IsConnected => _isConnected;
        
        /// <summary>
        /// Constructor.
        /// </summary>
        public WebRTCServer()
        {
            _screenCapture = new ScreenCapture(frameRate: 15);
            _keyboardInput = new KeyboardInput();
        }
        
        /// <summary>
        /// Inicializa la conexión WebRTC.
        /// </summary>
        public async Task Initialize()
        {
            LogToConsole("Inicializando WebRTC...");
            
            // Configurar peer connection
            var config = new RTCConfiguration
            {
                iceServers = new List<RTCIceServer>
                {
                    new RTCIceServer { urls = "stun:stun.l.google.com:19302" }
                }
            };
            
            // Crear peer connection
            _pc = new RTCPeerConnection(config);
            
            // Configurar eventos
            _pc.onicecandidate += OnIceCandidate;
            _pc.onconnectionstatechange += OnConnectionStateChange;
            _pc.ondatachannel += OnDataChannelAdded;
            
            // Configurar fuente de video
            _screenSource = new WindowsScreenSource();
            _frameSource = new VideoFramePump(_screenSource.GetVideoSource());
            var videoTrack = new MediaStreamTrack(
                SDPMediaTypesEnum.video,
                false,
                new List<SDPMediaFormat> { new SDPMediaFormat(SDPMediaFormatsEnum.VP8) },
                MediaStreamStatusEnum.SendOnly);
            
            _pc.addTrack(videoTrack);
            _frameSource.OnFrame += (frame) => videoTrack.SendVideo(frame);
            
            LogToConsole("WebRTC inicializado con éxito");
        }
        
        /// <summary>
        /// Crea una oferta SDP para iniciar la conexión.
        /// </summary>
        public async Task<RTCSessionDescriptionInit> CreateOffer()
        {
            LogToConsole("Creando oferta SDP...");
            
            if (_pc == null)
                throw new InvalidOperationException("WebRTC no inicializado.");
            
            // Crear canal de datos para controles
            _dataChannel = await _pc.createDataChannel("controls");
            _dataChannel.onmessage += OnDataChannelMessage;
            _dataChannel.onopen += () => LogToConsole("Canal de datos abierto");
            
            // Crear oferta
            var offer = _pc.createOffer();
            await _pc.setLocalDescription(offer);
            
            LogToConsole($"Oferta creada: {_pc.localDescription.sdp}");
            
            // Devolver descripción de sesión
            return new RTCSessionDescriptionInit
            {
                sdp = _pc.localDescription.sdp,
                type = RTCSdpType.offer
            };
        }
        
        /// <summary>
        /// Procesa una respuesta SDP del cliente.
        /// </summary>
        public async Task SetAnswer(RTCSessionDescriptionInit answer)
        {
            LogToConsole("Recibiendo respuesta SDP...");
            
            if (_pc == null)
                throw new InvalidOperationException("WebRTC no inicializado.");
            
            var desc = new RTCSessionDescription { sdp = answer.sdp, type = answer.type };
            await _pc.setRemoteDescription(desc);
            
            LogToConsole("Respuesta SDP establecida");
        }
        
        /// <summary>
        /// Procesa un candidato ICE del cliente.
        /// </summary>
        public async Task AddIceCandidate(RTCIceCandidateInit candidate)
        {
            if (_pc == null)
                throw new InvalidOperationException("WebRTC no inicializado.");
            
            await _pc.addIceCandidate(candidate);
        }
        
        /// <summary>
        /// Inicia la transmisión de video.
        /// </summary>
        public void StartVideoStreaming()
        {
            if (_isStreamingVideo)
                return;
            
            _isStreamingVideo = true;
            _frameSource?.Start();
            LogToConsole("Inicio de streaming de video");
        }
        
        /// <summary>
        /// Detiene la transmisión de video.
        /// </summary>
        public void StopVideoStreaming()
        {
            if (!_isStreamingVideo)
                return;
            
            _isStreamingVideo = false;
            _frameSource?.Stop();
            LogToConsole("Streaming de video detenido");
        }
        
        private void OnIceCandidate(RTCIceCandidate candidate)
        {
            // Este método sería llamado para enviar candidatos ICE al cliente
            // En una implementación completa, aquí enviaríamos el candidato al cliente
        }
        
        private void OnConnectionStateChange(RTCPeerConnectionState state)
        {
            LogToConsole($"Estado de conexión: {state}");
            
            if (state == RTCPeerConnectionState.connected)
            {
                _isConnected = true;
                StartVideoStreaming();
            }
            else if (state == RTCPeerConnectionState.disconnected || 
                     state == RTCPeerConnectionState.failed ||
                     state == RTCPeerConnectionState.closed)
            {
                _isConnected = false;
                StopVideoStreaming();
            }
            
            ConnectionStateChanged?.Invoke(this, state);
        }
        
        private void OnDataChannelAdded(RTCDataChannel dc)
        {
            _dataChannel = dc;
            _dataChannel.onmessage += OnDataChannelMessage;
            _dataChannel.onopen += () => LogToConsole("Canal de datos abierto (remoto)");
        }
        
        private void OnDataChannelMessage(string message)
        {
            try
            {
                LogToConsole($"Mensaje recibido: {message}");
                
                // Parsear JSON
                var keyEvent = JsonConvert.DeserializeObject<Dictionary<string, string>>(message);
                
                if (keyEvent != null &&
                    keyEvent.TryGetValue("type", out string? type) &&
                    keyEvent.TryGetValue("key", out string? key))
                {
                    if (type == "keydown")
                    {
                        _keyboardInput.KeyDown(key);
                    }
                    else if (type == "keyup")
                    {
                        _keyboardInput.KeyUp(key);
                    }
                }
            }
            catch (Exception ex)
            {
                LogToConsole($"Error al procesar mensaje: {ex.Message}");
            }
        }
        
        private void LogToConsole(string message)
        {
            LogMessage?.Invoke(this, message);
        }
        
        public void Dispose()
        {
            if (_isDisposed)
                return;
            
            _isDisposed = true;
            
            StopVideoStreaming();
            
            // Liberar recursos
            _screenCapture.Dispose();
            _screenSource?.Dispose();
            _frameSource?.Dispose();
            _dataChannel = null;
            
            if (_pc != null)
            {
                _pc.close();
                _pc = null;
            }
            
            LogToConsole("Recursos WebRTC liberados");
        }
    }
}
